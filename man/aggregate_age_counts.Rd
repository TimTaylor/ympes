% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_age_counts.R
\name{aggregate_age_counts}
\alias{aggregate_age_counts}
\alias{imp_aggregate_age_counts}
\alias{imp_aggregate_age_counts_c}
\title{Fast aggregation of counts across age groups}
\usage{
imp_aggregate_age_counts(
  counts,
  ages = 0:(length(counts) - 1L),
  limits = c(1L, 5L, 15L, 25L, 45L, 65L)
)

imp_aggregate_age_counts_c(
  counts,
  ages = 0:(length(counts) - 1L),
  limits = c(1L, 5L, 15L, 25L, 45L, 65L)
)
}
\arguments{
\item{counts}{\verb{[numeric]}.
Vector of counts to be aggregated.}

\item{ages}{\verb{[numeric]}.
Age in years corresponding to \code{counts}. Defaults to 0:(N-1) where \code{N} is
the number of counts present. Values will be coerced to integer before
categorisation.}

\item{limits}{\verb{[numeric]}.
1 or more unique and positive cut points. Values will be coerced to integer.}
}
\value{
A named vector of aggregated counts.
}
\description{
\code{imp_aggregate_age_counts()} provides aggregation of counts across ages (in
years). It is a similar to a \code{cut()} and \code{tapply()} pattern but is faster
due to the more restrictive output that is possible.
\code{imp_aggregate_age_counts_c()} is an experimental implementation of the
aforementioned function with the underlying implementation written in C for
additional performance.
}
\details{
The resultant groupings will span the natural numbers (from 0) and will
always be closed on the left and open on the right. For example, if
\code{limits = c(1,10,30)} the groupings will be
"[0, 1)", "[1, 10)", "[10, 30)", "[30, Inf)".
}
\examples{

counts <- 1:65

# default ages generated if only counts provided (here ages will be 0:64)
imp_aggregate_age_counts(counts)

# single limits permitted
imp_aggregate_age_counts(counts, limits = 50)

# NA ages are handled
ages <- counts
ages[1:44] <- NA
imp_aggregate_age_counts(counts, ages)

# no need for ages to be consecutive
imp_aggregate_age_counts(counts = c(1,10), ages = c(1,10), limits = c(1,10))

}
