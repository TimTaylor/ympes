% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_age_counts.R
\name{imp_aggregate_age_counts}
\alias{imp_aggregate_age_counts}
\title{Fast aggregation of counts across age groups}
\usage{
imp_aggregate_age_counts(
  counts,
  ages = 0:(length(counts) - 1L),
  limits = c(1L, 5L, 15L, 25L, 45L, 65L)
)
}
\arguments{
\item{counts}{\verb{[numeric]}. Vector of counts to be aggregated.}

\item{ages}{\verb{[numeric]}. Age in years corresponding to \code{counts}. Defaults to
0:(N-1) where \code{N} is the number of counts present.}

\item{limits}{\verb{[numeric]}. 1 or more unique and positive cut points.

The resultant groupings will span the natural numbers (from 0) and will
always be closed on the left and open on the right. To clarify, if
\code{limits = c(1,10,30)} the groupings will be "[0, 1)", "[1, 10)", "[10, 30)",
"[30, Inf)".}
}
\value{
A named vector of aggregated counts.
}
\description{
\code{imp_aggregate_age_counts()} provides fast aggregation of counts across
ages (in years). It is a similar to a \code{cut()} and \code{tapply()} pattern but
more optimised for a more specific use case.
}
\examples{

# default ages generated if only counts provided
counts <- 1:65
imp_aggregate_age_counts(counts) # here ages defaulted to 0:65

# single limit
imp_aggregate_age_counts(counts, limits = 50)

# handles NA ages
ages <- counts
ages[1:44] <- NA
imp_aggregate_age_counts(counts, ages)

# ages do not need to be consecutive
imp_aggregate_age_counts(counts = c(1,10), ages = c(1,10), limits = c(1,10))

}
