---
title: "Utilities for Working with Age Categories"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Utilities for Working with Age Categories}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

ympes provides a collection of functions for working with age intervals that
have been optimised for performance:

- `ages_to_interval()` provides categorisation of ages based on specified
  right-hand interval limits. The resultant groupings will span the natural
  numbers (from 0) and will always be closed on the left and open on the
  right. For example, if `limits = c(1,10,30)` the possible groupings will be
  "[0, 1)", "[1, 10)", "[10, 30)" and "[30, Inf)". This is roughly comparable
  to a call of `cut(ages, right = FALSE, breaks = c(0, limits))` but with the
  start and end points of the interval returned as entries in a list.

- `split_interval_counts()` splits counts within a age interval in to counts
  for individuals years based on a given weighting. Age intervals are
  specified by their lower (closed) and upper (open) bounds, i.e. intervals
  of the form [lower, upper).

- `aggregate_age_counts()` provides aggregation of counts across ages (in
  years). It is similar to a `cut()` and `tapply()` pattern but optimised for
  speed over flexibility. Groupings are the same as in `ages_to_interval()`
  and counts will be provided across all natural numbers as well as for
  missing values.

- `reaggregate_interval_counts()` is equivalent to, but more efficient than,
  calling `split_interval_counts()` and then `aggregate_age_counts()`.

```{r}
library(ympes)
```

Note that the default `limits` argument in all functions is set to 
limits = c(1L, 5L, 15L, 25L, 45L, 65L). We explicitly set this in the examples
below for clarity.

## Examples for `ages_to_interval()`

```{r}
ages_to_interval(ages = 0:9, limits = c(1L, 5L, 15L, 25L, 45L, 65L))

ages_to_interval(1:10, limits = 6L)

str(x <- ages_to_interval(1:100))

head(x$interval)
```

## Examples for `split_interval_counts()`

```{r}
# by default counts are split equally across ages within intervals
split_interval_counts(
    lower_bounds = c(0L, 5L, 10L),
    upper_bounds = c(5L, 10L, 20L),
    counts = c(5L, 10L, 30L)
)

# Population weightings to apply for individual years can be specified by
# the weights argument. If these are specified, they must be of length
# `max_upper` and represent weights in the range 0:(max_upper - 1).
max_upper <- 20L
weights <- integer(max_upper)
weights[c(TRUE, FALSE)] <- 1L
split_interval_counts(
    lower_bounds = c(0L, 5L, 10L),
    upper_bounds = c(5L, 10L, 20L),
    counts = c(5L, 10L, 30L),
    max_upper = max_upper,
    weights <- weights
)
```

## Examples for `aggregate_age_counts()`

```{r}
# default ages generated as 0:(length(counts) - 1L) if only counts provided.
aggregate_age_counts(counts = 1:65, limits = c(1L, 5L, 15L, 25L, 45L, 65L))

aggregate_age_counts(counts = 1:65, limits = 50)

# NA ages are handled with their own grouping
ages <- 1:65;
ages[1:44] <- NA
aggregate_age_counts(
    counts = 1:65,
    ages = ages,
    limits = c(1L, 5L, 15L, 25L, 45L, 65L)
)
```

## Example for `reaggregate_interval_counts()`

This is a basic example which shows you how to solve a common problem of
distributing counts in to a different set of age intervals from what you have
been given. We use some output obtained from the 2021 census and modify 
based on our desired interval limits. Note that `reaggregate_age_counts()` is
equivalent to applying `split_interval_counts()` followed by a a called to 
`aggregate_age_counts()`.

```{r}
# census data
data(pop_dat)
pop_dat

# each row is for the same region so discard for moment
dat <- subset(pop_dat, select = c(age_category, value))

# extract upper and lower bounds
dat <- transform(
    dat,
    lower_bound = as.numeric(sub("\\[([0-9]+), .+)", "\\1", age_category)),
    upper_bound = as.numeric(sub(".+, (.+))", "\\1", age_category))
)

head(dat, n =10)

# recategorise based on ages
with(
    dat, 
    reaggregate_interval_counts(
        lower_bounds = lower_bound,
        upper_bounds = upper_bound,
        counts = value,
        limits = c(1L, 5L, 15L, 25L, 45L, 65L),
        max_upper = 100L,
        weights = NULL
    )
)
```
